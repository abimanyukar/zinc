#!/usr/bin/env python3
#
# MIT License
#
# Copyright (c) 2017 Rokas Kupstys
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
"""
This is a demo utility demonstrating use of zinc library.

Usage:
1. Build block hashes:
    ./zinc --hash /path/to/file.iso /path/to/file.iso.json
2. Upload `file.iso` and `file.iso.json` to a directory on a webserver and serve them through http(s).
3. Use utility to synchronize your local file with file on the webserver:
    ./zinc http://webserver/path/to/file.iso /path/to/local/file.iso

Utility does it's best to reuse any data already present in a local file and downloads only missing bits.
The only requirement for a webserver is support of "Range" header.
"""
import os
import argparse
import json
import hashlib
import urllib.request

import progressbar
import pyzinc


class NetworkFile(object):
    def __init__(self, network_path):
        self._network_path = network_path
        self._position = 0
        self._length = int(urllib.request.urlopen(self._network_path).info().get('Content-Length', 0))

    def seek(self, offset, whence=os.SEEK_SET):
        if whence == os.SEEK_CUR:
            self._position = min(self._length, self._position + offset)
        elif whence == os.SEEK_SET:
            self._position = min(self._length, offset)
        elif whence == os.SEEK_END:
            self._position = min(self._length, self._length - offset)
        else:
            raise ValueError('Invalid `whence` value.')

    def read(self, length=None):
        if length is None:
            length = self._length - self._position
        request = urllib.request.Request(self._network_path, None, {
            'Range': 'bytes={}-{}'.format(self._position, self._position + length - 1),
            'User-Agent': 'zinc/1.0'
        })
        response = urllib.request.urlopen(request)
        data = response.read()
        self._position += len(data)
        return data

    def close(self):
        pass

    def tell(self):
        return self._position


def netopen(network_path):
    return NetworkFile(network_path)


def hash_files(args):
    if not os.path.isfile(args.input):
        raise FileNotFoundError()

    if os.path.isfile(args.output):
        if not args.force:
            raise FileExistsError()

    file_size = os.path.getsize(args.input)
    block_size = max(5 * 1024, min(4 * 1024 * 1024, int(file_size / 512)))
    chunk_size = 1024 * 1024

    sha256 = hashlib.sha256()
    with open(args.input, 'rb') as fp:
        bar = progressbar.ProgressBar(max_value=file_size, widgets=[
            'Hashing file: ', progressbar.Bar(), ' (', progressbar.ETA(), ') '
        ])
        for chunk in iter(lambda: fp.read(chunk_size), b''):
            sha256.update(chunk)
            bar.update(fp.tell())
        bar.update(fp.tell())
    sha256 = sha256.hexdigest().lower()

    print('\nHashing blocks...')
    checksums = pyzinc.get_block_checksums(args.input, block_size)
    with open(args.output, 'w+') as fp:
        json.dump({
            'filename': os.path.basename(args.input),
            'sha256': sha256,
            'file_size': file_size,
            'block_size': block_size,
            'blocks': [(c.weak, str(c.strong)) for c in checksums]
        }, fp, indent=4)
    print('Done')


def sync_files(args):
    fp_json = None
    fp_file = None
    try:
        hash_path = args.input + '.json'
        if args.input.startswith('http://') or args.input.startswith('https://'):
            opener = netopen
        else:
            opener = open
        fp_json = opener(hash_path)
        fp_file = opener(args.input)

        file_info = json.load(fp_json)

        hashes = [pyzinc.BlockHashes(*block) for block in file_info['blocks']]
        bar = progressbar.ProgressBar(max_value=file_info['file_size'], widgets=[
            'Building delta: ', progressbar.Bar(), ' (', progressbar.ETA(), ') '
        ])

        def report_progress(bytes_done_now, bytes_done_total, file_size):
            bar.update(bytes_done_total)
            return True

        def get_data(block_index, block_size):
            fp_file.seek(block_index * block_size)
            return fp_file.read(block_size)

        delta = pyzinc.get_differences_delta(args.output, file_info['block_size'], hashes, report_progress)
        if len(delta) == 0:
            print('Building delta failed')
        else:
            bar = progressbar.ProgressBar(max_value=file_info['file_size'], widgets=[
                'Syncing file: ', progressbar.Bar(), ' (', progressbar.ETA(), ') '
            ])
            if pyzinc.patch_file(args.output, file_info['file_size'], file_info['block_size'], delta, get_data,
                                   report_progress):
                sha256 = hashlib.sha256()
                with open(args.output, 'rb') as fp:
                    bar = progressbar.ProgressBar(max_value=file_info['file_size'], widgets=[
                        'Verifying: ', progressbar.Bar(), ' (', progressbar.ETA(), ') '
                    ])
                    for chunk in iter(lambda: fp.read(1024 * 1024), b''):
                        sha256.update(chunk)
                        bar.update(fp.tell())
                    bar.update(fp.tell())
                sha256 = sha256.hexdigest().lower()
                print()
                if sha256 == file_info['sha256']:
                    print('File saved to', args.output)
                else:
                    print('Hash miss-match')
            else:
                print('File synchronization failed')
    finally:
        if fp_file:
            fp_file.close()
        if fp_json:
            fp_json.close()


def zinc(args):
    if args.hash:
        hash_files(args)
    else:
        sync_files(args)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--hash', action='store_true', help='Build file hashes.')
    parser.add_argument('-f', '--force', action='store_true', help='Overwrite existing files.')
    parser.add_argument('input', help='Path or a URL to file.')
    parser.add_argument('output', help='Path to a file.')
    zinc(parser.parse_args())
